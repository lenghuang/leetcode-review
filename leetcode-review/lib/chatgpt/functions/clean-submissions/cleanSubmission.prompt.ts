const exampleSubmission = `class Solution:\n    \n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        nums1 = [float(\"-inf\")] + nums1 + [float(\"inf\")]\n        nums2 = [float(\"-inf\")] + nums2 + [float(\"inf\")]\n        m, n  = len(nums1), len(nums2)\n        if m > n: # ensure nums1 is smaller one\n            nums1, nums2, m, n = nums2, nums1, n, m\n        lo, hi = 1, m\n        while(lo <= hi):\n            i = (lo + hi) // 2\n            j = ((m + n) // 2) - i\n            if nums1[i] < nums2[j-1]:\n                lo = i + 1\n            elif nums2[j] < nums1[i-1]:\n                hi = i - 1\n            else:\n                maxL = max(nums1[i-1], nums2[j-1])\n                minR = min(nums1[i], nums2[j])\n                if (m + n) % 2 == 0:\n                    return (maxL + minR) / 2\n                else:\n                    return minR\n        return 0.0\n\n\n                \n                \n                \n        \n\n                \n'''\n\nlog(m + n) time => log( lists appended to each other ) or log ( nums1 ) + log (nums 2)\n\nHow do we find median in a single array? \n- Get it's length\n- If even, return average of elements at index (n//2, n//2 + 1).\n- If odd,  return the element at index (n//2). \n\nNow, we want to find it in two sorted arrays. If we try to do the same thing, \nwe run into the following issue:\n- Get it's length (m + n)\n- If even, return average of elements at index (m+n//2, m+n//2 + 1).\n- If odd,  return the elemtn at index (m+n//2).\n\nThis is problematic because we don't have a way to cleanly index between everything\nat least in a sorted way. They're all sorted relative to each other.\n\nNote that a solution with W(n) = W(n/2) + O(1) work is O(log(m+n)).\n\nFrom peering at the solutions there are two main approaches:\n- Binary search on both arrays, casing on the max/mins of either medians\n- Going through and removing the first few items k times, keep a pq of size 2?\n\nThe second one is out of time bounds but easier to implement, where as the first one is the optimal log(min(m,n)). \n\n*********************\n* O(m + n) SOLUTION *\n*********************\n\n- Keep two pointers\n- Keep track of k', until it's k = median point\n- If L is smaller, add that, increment k'\n- If R is bigger,  add that, increment k'\n- Once k' = k, return either the larger element or the sum of them.\n\n*********************\n* O(m + n) SOLUTION *\n*********************\n\nHere we do another version of an O(k) solution, but this will server as a stepping \nstone to our understanding of binary search.\n\nIn a single array, the median is an element in the array that has an equal number \nof elements below it and above it. For two arrays, the median could be in either \narray. As such, we want to find a point such that for some split in both arrays, \nthere as an equal number of left parts that are all less than or equal to the right parts.\n\nIf we have these two arrays\n[1,2]\n[3,4]\n\nA valid partition is \n[1,2 |]\n[| 3,4]\n\nWhere (2+3)/2 is the median, since in the left side (1,2,empty) there are two elements and\non the right side (empty,3,4) there are also two. With this splitting it is also true that \nall elements on the left side are less than or equal to all the ones in the right side.\n\nA more complicated example:\n\n[1,2,5,6]\n[3,4,8]\n\nA valid partition is\n\n[1,2 | 5,6]\n[3,  | 4,8]\n\nWhere 4 is the median since we have less things on the left side, we take the mins of the right side. The left side is (1,2,3) and the right side is (5,6,4,8).\n\nIf the goal is to find the partition, then we can use a suboptimal search technique\nto find this partition. More generally, for some \n\nA = [ ... A[i-1] | A[i] ... ]\nB = [ . B[j-1] | B[j] ..... ]\n\nIf |A| + |B| is even, then the median is the average of the bigger of the left side and \nsmaller on the right side, or (max(A[i-1],B[j-1]) + min(A[i],B[j])) / 2.\n\nWe have two variables here, i and j. So we can search across all partitions in O(n^2) time.\n'''`;
const exampleSubmissionClean = `def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n    nums1 = [float(\"-inf\")] + nums1 + [float(\"inf\")]\n    nums2 = [float(\"-inf\")] + nums2 + [float(\"inf\")]\n    m, n  = len(nums1), len(nums2)\n    if m > n: # ensure nums1 is smaller one\n        nums1, nums2, m, n = nums2, nums1, n, m\n    lo, hi = 1, m\n    while(lo <= hi):\n        i = (lo + hi) // 2\n        j = ((m + n) // 2) - i\n        if nums1[i] < nums2[j-1]:\n            lo = i + 1\n        elif nums2[j] < nums1[i-1]:\n            hi = i - 1\n        else:\n            maxL = max(nums1[i-1], nums2[j-1])\n            minR = min(nums1[i], nums2[j])\n            if (m + n) % 2 == 0:\n                return (maxL + minR) / 2\n            else:\n                return minR\n    return 0.0\n`;

export const getCleanSubmissionPrompt = (submission: string): string => {
  return `
    You are an expert at parsing LeetCode Data Structures and Algorithms Problems.
    You are just as skilled as an IDE, Linter, and Copilot at understanding code patterns.

    I have a small task for you. I will give you a snippet of code.
    There may be large chunks of comments, in it, specifically, multi-line comments in different programming languages.

    Remove all multi-line comments in the submission.
    Also remove comments that you think are not necessary or part of the core flow.

    Also cautiously remove some boilerplate code such as class declarations, and unindent the solution accordingly.
    These will normally look like "class Solution:" in Python "class Solution {}" in Java, and "class Solution {\npublic:\n}" in C++.

    Here's an example:
    ${exampleSubmission}

    Here's an example of it being cleaned up:
    ${exampleSubmissionClean}

    Can you give me a similarly cleaned up version for this code?
    ${submission}
    `;
};
